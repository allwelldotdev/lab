Kubernetes and Cloud Native Essentials (LFS250)
Taken from the Linux Foundation. Link -> https://trainingportal.linuxfoundation.org/courses/kubernetes-and-cloud-native-essentials-lfs250

## Characteristics of Cloud Native Architecture
1. High level of automation
2. Self healing
3. Scalable
4. Cost Efficient
5. Easy to maintain
6. Secure by default

### 1. High level of automation
To managing all the moving parts of a cloud native application, automation is required through software (like Terraform) and CI/CD pipelines which utilize version control systems like git. A reliable automated system also enables easier disaster recovery processes - think if you have to rebuild your whole system.

### 2. Self Healing
Because applications and infrastructure fail from time to time, cloud native applications have the ability to restart services when they fail their health checks. Though, since apps are compartmentalized (as microservices), there is a chance that when one part of the app fails, only that part is down while others are up and running fine, until the failed part is restarted.

### 3. Scalable
Scaling applications is the process of handling more load while still providing a seamless user experience for users. In cloud native applications, "scaling out" is the common scaing method. 

### 4. Cost efficient
Just like scaling up your application for high traffic situations, scaling down your application and the usage-based pricing models of cloud providers can save costs if traffic is low.

### 5. Easy to maintain
Using _Microservices_ allows to break down applications in smaller pieces and make them more portable, easier to test and to distribute across multiple teams.

### 6. Secure by default
In the cloud native environment, patterns like zero trust computing ensure secure procedures by requiring authentication from every user and process.

> While these patterns and technologies provide full advantage if they run in the cloud, they can also offer a lot of benefits when applied to on-premises systems. Last but not least, they allow a smoother transition if you migrate your applications and infrastructure to the cloud.

## Serverless
Applications that are written for serverless platforms have even stricter requirements for cloud native architecture, but at the same time can benefit most from them. Writing small, stateless applications make them a perfect fit for event or data streams, scheduled tasks, business logic or batch processing.

## Open Standards
Under the umbrella of the Linux Foundation, the Open Container Initiative provides two standards which define the way how to build and run containers.

Open standards like this help and complement other systems like Kubernetes, which is the _de facto_ standard platform for orchestrating containers. A few standards that will discover in the following chapters are:

- [OCI Spec](https://opencontainers.org/): image, runtime and distribution specification on how to run, build an distribute containers
- [Container Network Interface (CNI)](https://github.com/containernetworking/cni): A specification on how to implement networking for Containers.
- [Container Runtime Interface (CRI)](https://github.com/kubernetes/cri-api): A specification on how to implement container runtimes in container orchestration systems.
- [Container Storage Interface (CSI)](https://github.com/container-storage-interface/spec): A specification on how to implement storage in container orchestration systems.
- [Service Mesh Interface (SMI)](https://smi-spec.io/): A specification on how to implement Service Meshes in container orchestration systems with a focus on Kubernetes.

Following this approach, other systems like Prometheus or OpenTelemetry evolved and thrived in this ecosystem and provide additional standards for monitoring and observability.




